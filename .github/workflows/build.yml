# This is a Windows-only workflow that clones the public avm GitLab repo,
# installs clang/cmake/git/python/yasm, ensures yasm is on PATH, and extracts
# any .tar.gz files found inside the avm repo into their containing folders.

name: Build

permissions:
  # Need to be able to delete workflow runs
  actions: write
  # read access to repo contents (not strictly required here, but commonly useful)
  contents: read

on:
  schedule:
    # 每天北京时间8点运行（UTC时间0点）
    - cron: '0 0 * * *'
  workflow_dispatch:

jobs:
  windows-build:
    runs-on: windows-latest

    steps:
      # Checkout this repository (if you still need files from this repo)
      - name: Checkout this repo
        uses: actions/checkout@v4

      # Clone the public AVM repo (no token needed)
      - name: Clone public AVM GitLab repo
        shell: pwsh
        run: |
          # Clone into a subfolder 'avm'
          git clone https://gitlab.com/AOMediaCodec/avm.git avm
          Write-Host "Clone complete. Listing avm top-level:"
          Get-ChildItem avm -Force

      # Install required tools via Chocolatey
      - name: Install build tools with Chocolatey
        shell: pwsh
        run: |
          choco install -y --limit-output cmake git python3 nasm 7zip strawberryperl ffmpeg
          # Wait up to ~30s for tools to appear in PATH if necessary
          $tries = 0
          while ($tries -lt 15 -and -not (Get-Command clang -ErrorAction SilentlyContinue)) {
            Start-Sleep -Seconds 2
            $tries++
          }
          Write-Host "Chocolatey install step finished."

      # Ensure likely tool locations are on PATH for the remainder of the job
      - name: Add common tool locations to PATH
        shell: pwsh
        run: |
          $paths = @(
            'C:\ProgramData\chocolatey\bin',
            'C:\Program Files\LLVM\bin',
            'C:\Program Files\CMake\bin'
          )
          foreach ($p in $paths) {
            if (Test-Path $p) {
              Add-Content -Path $env:GITHUB_PATH -Value $p
              Write-Host "Added $p to PATH"
            } else {
              Write-Host "Not present: $p"
            }
          }

      # Verify the installed tools (sanity check)
      - name: Verify installed tools
        shell: pwsh
        run: |
          Write-Host "clang: $(if (Get-Command clang -ErrorAction SilentlyContinue) { (clang --version | Select-Object -First 1) } else { 'clang not found' })"
          Write-Host "cmake: $(if (Get-Command cmake -ErrorAction SilentlyContinue) { (cmake --version | Select-Object -First 1) } else { 'cmake not found' })"
          Write-Host "python: $(if (Get-Command python -ErrorAction SilentlyContinue) { (python --version) } else { 'python not found' })"
          Write-Host "git: $(git --version)"
          Write-Host "yasm: $(if (Get-Command yasm -ErrorAction SilentlyContinue) { (yasm --version 2>&1 | Select-Object -First 1) } else { 'yasm not found' })"

      # Extract every .tar.gz found under the avm repo into its containing folder
      - name: Extract .tar.gz archives in avm
        shell: pwsh
        run: |
          $repoDir = Join-Path $env:GITHUB_WORKSPACE 'avm'
          if (-not (Test-Path $repoDir)) {
            Write-Error "avm repo not found at $repoDir"
            exit 1
          }
          Write-Host "Searching for .tar.gz files under $repoDir ..."
          $archives = Get-ChildItem -Path $repoDir -Filter *.tar.gz -Recurse -File
          if ($archives.Count -eq 0) {
            Write-Host "No .tar.gz files found."
            exit 0
          }
          foreach ($a in $archives) {
            $file = $a.FullName
            $targetDir = $a.DirectoryName
            Write-Host "Processing: $file -> $targetDir"

            # Try native tar first (tar -xzf)
            try {
              tar -xzf $file -C $targetDir
              Write-Host "Extracted with tar: $file"
              continue
            } catch {
              Write-Host "tar extraction failed for $file. Falling back to 7z method."
            }

            # Fallback: use 7z to extract gzip then tar (temporary dir used)
            $tmp = Join-Path $env:TEMP ("avm_extract_{0}" -f ([guid]::NewGuid().ToString()))
            New-Item -ItemType Directory -Path $tmp | Out-Null
            try {
              # Extract the .tar from .tar.gz into tmp
              & 7z x $file -o$tmp -y | Out-Null
              # Find the extracted .tar
              $tarfile = Get-ChildItem -Path $tmp -Filter *.tar -Recurse -File | Select-Object -First 1
              if ($null -eq $tarfile) {
                throw "7z did not produce a .tar for $file"
              }
              # Extract the .tar into the target directory
              & 7z x $tarfile.FullName -o$targetDir -y | Out-Null
              Write-Host "Extracted with 7z fallback: $file"
            } catch {
              Write-Error "Failed to extract $file : $_"
              throw
            } finally {
              # Clean up temp
              Remove-Item -Path $tmp -Recurse -Force -ErrorAction SilentlyContinue
            }
          }
          Write-Host "All archives processed. Listing top-level of avm:"
          Get-ChildItem -Path $repoDir -Force

      # Placeholder: add your CMake / build commands here
      - name: Configure and build
        shell: pwsh
        run: |
          Write-Host "my script start"
          cd avm
          mkdir -p ..\aom_build
          cd ..\aom_build
          cmake -G "Ninja" -S . -DAOM_TARGET_CPU=generic -B build -DCMAKE_C_COMPILER=clang-cl -DCMAKE_CXX_COMPILER=clang-cl "-DCMAKE_POLICY_VERSION_MINIMUM=3.5" -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=0 -DCMAKE_RUNTIME_OUTPUT_DIRECTORY=D:/a/avm_autobuild_binary_win/avm_autobuild_binary_win/aom_build/build/output -Wno-dev D:\a\avm_autobuild_binary_win\avm_autobuild_binary_win\avm
          cmake -LA D:\a\avm_autobuild_binary_win\avm_autobuild_binary_win\avm
          cd D:/a/avm_autobuild_binary_win/avm_autobuild_binary_win/aom_build/build
          ninja
          Write-Host "build end"
          D:/a/avm_autobuild_binary_win/avm_autobuild_binary_win/aom_build/build/output/aomenc.exe --help

      - name: Archive build output with 7-Zip
        shell: powershell
        run: |
          $seven = "${env:ProgramFiles}\7-Zip\7z.exe"
          if (-not (Test-Path $seven)) {
            Write-Error "7z not found at $seven. On hosted windows-latest it should be installed by default."
            exit 1
          }
          New-Item -ItemType Directory -Path out -Force | Out-Null
          # Create a 7z archive (maximum compression). Adjust -mx=9 to change compression level.
          & $seven a -t7z "out\build.7z" "D:/a/avm_autobuild_binary_win/avm_autobuild_binary_win/aom_build/build/output/" -mx=9
          Write-Output "Created out\build.7z"

      - name: Upload 7z build artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-artifact-7z
          path: out/build.7z
          retention-days: 30
          
      # test encode(add on 20251029 2241BJT
      - name: Encode a test video using ffmpeg
        shell: pwsh
        run: |
          ffmpeg -f lavfi -i testsrc2=duration=4:size=640x480:rate=30 -strict -1 D:/a/test.y4m
          D:/a/avm_autobuild_binary_win/avm_autobuild_binary_win/aom_build/build/output/aomenc.exe --good --verbose --ivf --end-usage=q --target-bitrate=300 --min-qp=50 --overshoot-pct=5 --undershoot-pct=100 --enable-fwd-kf=120 --cpu-used=4 --tune=ssim --qp=70 --lag-in-frames=48 --max-intra-rate=128 --min-partition-size=4 --max-partition-size=256 --coeff-cost-upd-freq=2  --mode-cost-upd-freq=2 --mv-cost-upd-freq=2  --threads=16 --sb-size=dynamic --aq-mode=2 --max-reference-frames=7 --passes=1 -o D:/a/avm_autobuild_binary_win/avm_autobuild_binary_win/aom_build/build/output/testenc.ivf D:/a/test.y4m
          D:/a/avm_autobuild_binary_win/avm_autobuild_binary_win/aom_build/build/output/aomdec.exe --summary -o D:/a/testaftenc.y4m D:/a/avm_autobuild_binary_win/avm_autobuild_binary_win/aom_build/build/output/testenc.ivf
          ffmpeg.exe -i D:/a/testaftenc.y4m -c:v ffv1 -level 3 -slices 4 -map 0:v D:/a/testaftenc.mkv
          
      - name: Upload test encode ivf
        uses: actions/upload-artifact@v4
        with:
          name: testenc.ivf
          path: D:/a/avm_autobuild_binary_win/avm_autobuild_binary_win/aom_build/build/output/testenc.ivf
          retention-days: 30
          
      - name: Upload after encode ffv1 mkv video
        uses: actions/upload-artifact@v4
        with:
          name: testaftenc.mkv
          path: D:/a/testaftenc.mkv
          retention-days: 30
          
      # Final step: prune workflow runs older than 15 days (runs regardless of success/failure)
#      - name: Prune workflow runs older than 15 days
 #       if: always()
 #       shell: pwsh
 #       run: |
          # This script uses the repository's GITHUB_TOKEN and requires permissions.actions: write (set above).
 #         $repo = $env:GITHUB_REPOSITORY
 #         $token = $env:GITHUB_TOKEN
 #         $currentRunId = [int]$env:GITHUB_RUN_ID
 #         $cutoff = (Get-Date).AddDays(-15)
 #         if (-not $token) {
 #           Write-Warning "GITHUB_TOKEN is not available; cannot prune runs."
 #           exit 0
 #         }
#
#          Write-Host "Pruning workflow runs in $repo older than $($cutoff.ToString('u')) (skipping current run id $currentRunId)..."
#
#          $per_page = 100
#          $page = 1
#          while ($true) {
#            $url = "https://api.github.com/repos/$repo/actions/runs?per_page=$per_page&page=$page"
#            try {
#              $resp = Invoke-RestMethod -Uri $url -Headers @{
#                Authorization = "Bearer $token"
#                Accept = "application/vnd.github.v3+json"
#                'User-Agent' = 'github-actions/prune-script'
#              } -Method Get
#            } catch {
#              Write-Error "Failed to list workflow runs: $_"
#              break
#            }
#
#            $runs = $resp.workflow_runs
#            if (-not $runs -or $runs.Count -eq 0) {
#              break
#            }

#            foreach ($r in $runs) {
#              try {
#                $created = [DateTime]::Parse($r.created_at)
#              } catch {
#                Write-Warning "Could not parse created_at for run id $($r.id), skipping."
#                continue
#              }
#              if ($created -lt $cutoff) {
#                $rid = [int]$r.id
#                if ($rid -eq $currentRunId) {
#                  Write-Host "Skipping current run $rid."
#                  continue
#                }
#                Write-Host "Deleting run $rid (created: $created, workflow: $($r.name), status: $($r.status))"
#                $delUrl = "https://api.github.com/repos/$repo/actions/runs/$rid"
#                try {
#                  Invoke-RestMethod -Uri $delUrl -Headers @{
#                    Authorization = "Bearer $token"
#                    Accept = "application/vnd.github.v3+json"
#                    'User-Agent' = 'github-actions/prune-script'
#                  } -Method Delete
#                  Write-Host "Deleted run $rid"
#                } catch {
#                  Write-Warning "Failed to delete run ${rid}: $_"
#                }
#              } else {
                # runs are returned newest-first; if this run is newer than cutoff, subsequent ones on same page may still be older,
                # so we continue checking all items on the page.
#                Write-Host "Keeping run $($r.id) created $created"
#              }
#            }

            # If we received fewer than per_page runs, we're on the last page
#            if ($runs.Count -lt $per_page) { break }
#            $page++
#          }

#          Write-Host "Prune step finished."



